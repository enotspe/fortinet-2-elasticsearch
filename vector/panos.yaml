#                                    __   __  __
#                                    \ \ / / / /
#                                     \ V / / /
#                                      \_/  \/
#
#                                    V E C T O R
#                                   Configuration
#
# ------------------------------------------------------------------------------
# Website: https://vector.dev
# Docs: https://vector.dev/docs
# Chat: https://chat.vector.dev
# ------------------------------------------------------------------------------

# Change this to use a non-default directory for Vector data storage:
# data_dir: "/var/lib/vector"

# Random Syslog-formatted logs
sources:
  syslog_panos:
    type: "syslog"
    address: 0.0.0.0:${PANOS_SYSLOG_UDP_PORT:-5140}
    mode: "udp"

#enrichment_tables:
#  iana_number:
#    type: "file"
#    file:
#      path: "/etc/vector/iana_number.csv"
#      encoding:
#        type: "csv"
#    schema:
#      Decimal: "integer"
#      Keyword: "string"

transforms:
  remap_pan:
    type: "remap"
    inputs: ["syslog_panos"]
    source: |
      # Rename syslog fields from "."
      .log.syslog.facility.name = del(.facility)
      .log.source.address = del(.source_ip)
      .log.syslog.hostname = del(.hostname)
      .log.syslog.host = del(.host)
      .log.syslog.severity.name = del(.severity)
      .log.syslog.version = del(.version)
      .log.logger = del(.source_type)
      .log.syslog.procid = del(.procid)
      .log.syslog.appname = del(.appname)

      # For Elasticsearch
      #.@timestamp = del(.timestamp) # not necessary https://vector.dev/docs/reference/configuration/sinks/elasticsearch/#mode

      .observer.hostname = .log.syslog.hostname
      .observer.name = .log.syslog.host
      .observer.product = "PanOS"
      .observer.type = "firewall"
      .observer.vendor = "Palo Alto"

      # parse values from message
      panos_values_array = parse_csv(.message) ?? null

      traffic_keys_array  = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","src","dst","natsrc","natdst","rule","srcuser","dstuser","app","vsys","from","to","inbound_if","outbound_if","logset","FUTURE_USE","sessionid","repeatcnt","sport","dport","natsport","natdport","flags","proto","action","bytes","bytes_sent","bytes_received","packets","start","elapsed","category","FUTURE_USE","seqno","actionflags","srcloc","dstloc","FUTURE_USE","pkts_sent","pkts_received","session_end_reason","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","action_source","src_uuid","dst_uuid","tunnel_id/imsi","monitortag/imei","parent_session_id","parent_start_time","tunnel","assoc_id","chunks","chunks_sent","chunks_received","rule_uuid","http2_connection","link_change_count","policy_id","link_switches","sdwan_cluster","sdwan_device_type","sdwan_cluster_type","sdwan_site","dynusergroup_name","xff_ip","src_category","src_profile","src_model","src_vendor","src_osfamily","src_osversion","src_host","src_mac","dst_category","dst_profile","dst_model","dst_vendor","dst_osfamily","dst_osversion","dst_host","dst_mac","container_id","pod_namespace","pod_name","src_edl","dst_edl","hostid","serial","src_dag","dst_dag","session_owner","high_res_timestamp","nssai_sst","nssai_sd","subcategory_of_app","category_of_app","technology_of_app","risk_of_app","characteristic_of_app","container_of_app","tunneled_app","is_saas_of_app","sanctioned_state_of_app","offloaded","flow_type","cluster_name","ai_traffic","ai_fwd_error","k8s_cluster_id","tcp_rtt_c2s","tcp_rtt_s2c","total_n_ooseq_c2s","total_n_ooseq_s2c","tcp_retransit_cnt_c2s","tcp_retransit_cnt_s2c","tcp_zero_window_cnt_c2s","tcp_zero_window_cnt_s2c","src_adv_dev_id","dst_adv_dev_id"]

      threat_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","src","dst","natsrc","natdst","rule","srcuser","dstuser","app","vsys","from","to","inbound_if","outbound_if","logset","FUTURE_USE","sessionid","repeatcnt","sport","dport","natsport","natdport","flags","proto","action","misc","threatid","category","severity","direction","seqno","actionflags","srcloc","dstloc","FUTURE_USE","contenttype","pcap_id","filedigest","cloud","url_idx","user_agent","filetype","xff","referer","sender","subject","recipient","reportid","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","FUTURE_USE","src_uuid","dst_uuid","http_method","tunnel_id/imsi","monitortag/imei","parent_session_id","parent_start_time","tunnel","thr_category","contentver","FUTURE_USE","assoc_id","ppid","http_headers","url_category_list","rule_uuid","http2_connection","dynusergroup_name","xff_ip","src_category","src_profile","src_model","src_vendor","src_osfamily","src_osversion","src_host","src_mac","dst_category","dst_profile","dst_model","dst_vendor","dst_osfamily","dst_osversion","dst_host","dst_mac","container_id","pod_namespace","pod_name","src_edl","dst_edl","hostid","serial","domain_edl","src_dag","dst_dag","partial_hash","high_res_timestamp","reason","justification","nssai_sst","subcategory_of_app","category_of_app","technology_of_app","risk_of_app","characteristic_of_app","container_of_app","tunneled_app","is_saas_of_app","sanctioned_state_of_app","cloud_reportid","flow_type","cluster_name"]

      url_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","src","dst","natsrc","natdst","rule","srcuser","dstuser","app","vsys","from","to","inbound_if","outbound_if","logset","FUTURE_USE","sessionid","repeatcnt","sport","dport","natsport","natdport","flags","proto","action","misc","threatid","category","severity","direction","seqno","actionflags","srcloc","dstloc","FUTURE_USE","contenttype","pcap_id","filedigest","cloud","url_idx","user_agent","filetype","xff","referer","sender","subject","recipient","reportid","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","FUTURE_USE","src_uuid","dst_uuid","http_method","tunnel_id/imsi","monitortag/imei","parent_session_id","parent_start_time","tunnel","thr_category","contentver","FUTURE_USE","assoc_id","ppid","http_headers","url_category_list","rule_uuid","http2_connection","dynusergroup_name","xff_ip","src_category","src_profile","src_model","src_vendor","src_osfamily","src_osversion","src_host","src_mac","dst_category","dst_profile","dst_model","dst_vendor","dst_osfamily","dst_osversion","dst_host","dst_mac","container_id","pod_namespace","pod_name","src_edl","dst_edl","hostid","serial","domain_edl","src_dag","dst_dag","partial_hash","high_res_timestamp","reason","justification","nssai_sst","subcategory_of_app","category_of_app","technology_of_app","risk_of_app","characteristic_of_app","container_of_app","tunneled_app","is_saas_of_app","sanctioned_state_of_app","cloud_reportid","cluster_name","flow_type"]

      data_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","src","dst","natsrc","natdst","rule","srcuser","dstuser","app","vsys","from","to","inbound_if","outbound_if","logset","FUTURE_USE","sessionid","repeatcnt","sport","dport","natsport","natdport","flags","proto","action","misc","threatid","category","severity","direction","seqno","actionflags","srcloc","dstloc","FUTURE_USE","contenttype","pcap_id","filedigest","cloud","url_idx","user_agent","filetype","xff","referer","sender","subject","recipient","reportid","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","FUTURE_USE","src_uuid","dst_uuid","http_method","tunnel_id/imsi","monitortag/imei","parent_session_id","parent_start_time","tunnel","thr_category","contentver","FUTURE_USE","assoc_id","ppid","http_headers","url_category_list","rule_uuid","http2_connection","dynusergroup_name","xff_ip","src_category","src_profile","src_model","src_vendor","src_osfamily","src_osversion","src_host","src_mac","dst_category","dst_profile","dst_model","dst_vendor","dst_osfamily","dst_osversion","dst_host","dst_mac","container_id","pod_namespace","pod_name","src_edl","dst_edl","hostid","serial","domain_edl","src_dag","dst_dag","partial_hash","high_res_timestamp","reason","justification","nssai_sst","subcategory_of_app","category_of_app","technology_of_app","risk_of_app","characteristic_of_app","container_of_app","tunneled_app","is_saas_of_app","sanctioned_state_of_app","cloud_reportid","cluster_name","flow_type"]

      hip_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","srcuser","vsys","machinename","os","src","matchname","repeatcnt","matchtype","FUTURE_USE","FUTURE_USE","seqno","actionflags","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","vsys_id","srcipv6","hostid","serialnumber","mac","high_res_timestamp","cluster_name"]

      globalprotect_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","vsys","eventid","stage","auth_method","tunnel_type","srcuser","srcregion","machinename","public_ip","public_ipv6","private_ip","private_ipv6","hostid","serialnumber","client_ver","client_os","client_os_ver","repeatcnt","reason","error","opaque","status","location","login_duration","connect_method","error_code","portal","seqno","actionflags","high_res_timestamp","selection_type","response_time","priority","attempted_gateways","gateway","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","vsys_id","cluster_name"]

      iptag_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","vsys","src","tag_name","eventid","repeatcnt","timeout","datasourcename","datasource_type","datasource_subtype","seqno","actionflags","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","vsys_id","high_res_timestamp","cluster_name"]

      userid_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","vsys","ip","user","datasourcename","eventid","repeatcnt","timeout","beginport","endport","datasource","datasourcetype","seqno","actionflags","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","vsys_id","factortype","factorcompletiontime","factorno","ugflags","userbysource","tag_name","high_res_timestamp","origindatasource","FUTURE_USE","cluster_name"]

      decryption_keys_array = ["receive_time","serial","type","subtype","config_ver","time_generated","src","dst","natsrc","natdst","rule","srcuser","dstuser","app","vsys","from","to","inbound_if","outbound_if","logset","time_received","sessionid","repeatcnt","sport","dport","natsport","natdport","flags","proto","action","tunnel","FUTURE_USE","FUTURE_USE","src_uuid","dst_uuid","rule_uuid","hs_stage_c2f","hs_stage_f2s","tls_version","tls_keyxchg","tls_enc","tls_auth","policy_name","ec_curve","err_index","root_status","chain_status","proxy_type","cert_serial","fingerprint","notbefore","notafter","cert_ver","cert_size","cn_len","issuer_len","rootcn_len","sni_len","cert_flags","cn","issuer_cn","root_cn","sni","error","container_id","pod_namespace","pod_name","src_edl","dst_edl","src_dag","dst_dag","high_res_timestamp","src_category","src_profile","src_model","src_vendor","src_osfamily","src_osversion","src_host","src_mac","dst_category","dst_profile","dst_model","dst_vendor","dst_osfamily","dst_osversion","dst_host","dst_mac","seqno","actionflags","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","vsys_id","subcategory_of_app","category_of_app","technology_of_app","risk_of_app","characteristic_of_app","container_of_app","is_saas_of_app","sanctioned_state_of_app","cluster_name"]

      tunnelinspection_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","src","dst","natsrc","natdst","rule","srcuser","dstuser","app","vsys","from","to","inbound_if","outbound_if","logset","FUTURE_USE","sessionid","repeatcnt","sport","dport","natsport","natdport","flags","proto","action","severity","seqno","actionflags","srcloc","dstloc","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","tunnelid","monitortag","parent_session_id","parent_start_time","tunnel","bytes","bytes_sent","bytes_received","packets","pkts_sent","pkts_received","max_encap","unknown_proto","strict_check","tunnel_fragment","sessions_created","sessions_closed","session_end_reason","action_source","start","elapsed","tunnel_insp_rule","remote_user_ip","remote_user_id","rule_uuid","pcap_id","dynusergroup_name","src_edl","dst_edl","high_res_timestamp","nssai_sd","nssai_sd","pdu_session_id","subcategory_of_app","category_of_app","technology_of_app","risk_of_app","characteristic_of_app","container_of_app","is_saas_of_app","sanctioned_state_of_app","cluster_name"]

      sctp_keys_array = ["receive_time","serial","type","FUTURE_USE","FUTURE_USE","time_generated","src","dst","FUTURE_USE","FUTURE_USE","rule","FUTURE_USE","FUTURE_USE","FUTURE_USE","vsys","from","to","inbound_if","outbound_if","logset","FUTURE_USE","sessionid","repeatcnt","sport","dport","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","proto","action","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","seqno","FUTURE_USE","assoc_id","ppid","severity","sctp_chunk_type","FUTURE_USE","verif_tag_1","verif_tag_2","sctp_cause_code","diam_app_id","diam_cmd_code","diam_avp_code","stream_id","assoc_end_reason","op_code","sccp_calling_ssn","sccp_calling_gt","sctp_filter","chunks","chunks_sent","chunks_received","packets","pkts_sent","pkts_received","rule_uuid","high_res_timestamp"]

      authentication_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","vsys","ip","user","normalize_user","object","authpolicy","repeatcnt","authid","vendor","logset","serverprofile","desc","clienttype","event","factorno","seqno","actionflags","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","vsys_id","authproto","rule_uuid","high_res_timestamp","src_category","src_profile","src_model","src_vendor","src_osfamily","src_osversion","src_host","src_mac","region","FUTURE_USE","user_agent","sessionid","cluster_name"]

      config_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","host","vsys","cmd","admin","client","result","path","before-change-detail","after-change-detail","seqno","actionflags","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","dg_id","comment","FUTURE_USE","high_res_timestamp"]

      system_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","vsys","eventid","object","FUTURE_USE","FUTURE_USE","module","severity","opaque","seqno","actionflags","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","FUTURE_USE","FUTURE_USE","high_res_timestamp"]

      correlated_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","src","srcuser","vsys","category","severity","dg_hier_level_1","dg_hier_level_2","dg_hier_level_3","dg_hier_level_4","vsys_name","device_name","vsys_id","objectname","object_id","evidence"]

      gtp_keys_array = ["receive_time","serial","type","subtype","FUTURE_USE","time_generated","src","dst","FUTURE_USE","FUTURE_USE","rule","FUTURE_USE","FUTURE_USE","app","vsys","from","to","inbound_if","outbound_if","logset","FUTURE_USE","sessionid","FUTURE_USE","sport","dport","FUTURE_USE","FUTURE_USE","FUTURE_USE","proto","action","event_type","msisdn","apn","rat","msg_type","end_ip_adr","teid1","teid2","gtp_interface","cause_code","severity","mcc","mnc","area_code","cell_id","event_code","FUTURE_USE","FUTURE_USE","srcloc","dstloc","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","imsi","imei","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","FUTURE_USE","start","elapsed","tunnel_insp_rule","remote_user_ip","remote_user_id","rule_uuid","pcap_id","high_res_timestamp","nsdsai_sst","nsdsai_sd","subcategory_of_app","category_of_app","technology_of_app","risk_of_app","characteristic_of_app","container_of_app","is_saas_of_app","sanctioned_state_of_app"]


      # panos_values_array[2] is "type" in all PANOS logs
      # panos_values_array[3] is "subtype" in all PANOS logs
      if panos_values_array[2] == "TRAFFIC" {
        .panos = object_from_array(panos_values_array, keys: traffic_keys_array) ?? null
      } else if panos_values_array[2] == "THREAT" {
        .panos = object_from_array(panos_values_array, keys: threat_keys_array) ?? null
      } else if panos_values_array[2] == "HIP-MATCH" {
        .panos = object_from_array(panos_values_array, keys: hip_keys_array) ?? null
      } else if panos_values_array[2] == "GLOBALPROTECT" {
        .panos = object_from_array(panos_values_array, keys: globalprotect_keys_array) ?? null
      } else if panos_values_array[2] == "IPTAG" {
        .panos = object_from_array(panos_values_array, keys: iptag_keys_array) ?? null
      } else if panos_values_array[2] == "USERID" {
        .panos = object_from_array(panos_values_array, keys: userid_keys_array) ?? null
      } else if panos_values_array[2] == "DECRYPTION" {
        .panos = object_from_array(panos_values_array, keys: decryption_keys_array) ?? null
      } else if panos_values_array[2] == "START" {
        .panos = object_from_array(panos_values_array, keys: tunnelinspection_keys_array) ?? null
      } else if panos_values_array[2] == "SCTP" {
        .panos = object_from_array(panos_values_array, keys: sctp_keys_array) ?? null
      } else if panos_values_array[2] == "AUTHENTICATION" {
        .panos = object_from_array(panos_values_array, keys: authentication_keys_array) ?? null
      } else if panos_values_array[2] == "CONFIG" {
        .panos = object_from_array(panos_values_array, keys: config_keys_array) ?? null
      } else if panos_values_array[2] == "SYSTEM" {
        .panos = object_from_array(panos_values_array, keys: system_keys_array) ?? null
      } else if panos_values_array[2] == "CORRELATION" {
        .panos = object_from_array(panos_values_array, keys: correlated_keys_array) ?? null
      } else if panos_values_array[2] == "GTP" {
        .panos = object_from_array(panos_values_array, keys: gtp_keys_array) ?? null
      }

      #timesptamp
      #.timestamp = to_string(.panos.high_res_timestamp) ?? now()

      # source
      .source.ip = .panos.src
      .source.port = to_int( string(.panos.sport) ?? "nonum" ) ?? null
      .source.mac = .panos.src_mac
      .source.nat.ip = .panos.natsrc
      .source.nat.port = to_int( string(.paos.natsport) ?? "nonum" ) ?? null
      .source.user.name = .panos.srcuser
      .source.user.group.name = .panos.dynusergroup_name
      .source.bytes = to_int( string(.panos.bytes_sent) ?? "nonum" ) ?? null
      .source.packets = to_int( string(.panos.pkts_sent) ?? "nonum" ) ?? null

      # Function to classify an IP address based on its type (IPv4 & IPv6)
      if ip_cidr_contains(["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"], .source.ip) ?? false {
          .source.ip_type = "private"
      } else if ip_cidr_contains(["127.0.0.0/8", "::1/128"], .source.ip) ?? false {
          .source.ip_type = "loopback"
      } else if ip_cidr_contains(["169.254.0.0/16", "fe80::/10"], .source.ip) ?? false {
          .source.ip_type = "link_local"
      } else if ip_cidr_contains(["224.0.0.0/4", "ff00::/8"], .source.ip) ?? false {
          .source.ip_type = "multicast"
      } else if ip_cidr_contains(["100.64.0.0/10"], .source.ip) ?? false {
          .source.ip_type = "carrier_nat"
      } else if ip_cidr_contains(["192.0.0.0/24", "192.0.2.0/24", "198.51.100.0/24", "203.0.113.0/24", "2001:db8::/32"], .source.ip) ?? false {
          .source.ip_type = "documentation"
      } else if ip_cidr_contains(["240.0.0.0/4", "2001::/23", "4000::/2"], .source.ip) ?? false {
          .source.ip_type = "reserved"
      } else if ip_cidr_contains(["100::/64"], .source.ip) ?? false {
          .source.ip_type = "discard" # IPv6 discard prefix (RFC 6666)
      } else if ip_cidr_contains(["2002::/16"], .source.ip) ?? false {
          .source.ip_type = "6to4_tunnel" # IPv6 6to4 tunneling
      } else if ip_cidr_contains(["::ffff:0:0/96"], .source.ip) ?? false {
          .source.ip_type = "ipv4_mapped" # IPv4-mapped IPv6
      } else if ip_cidr_contains(["::/128"], .source.ip) ?? false {
          .source.ip_type = "unspecified" # Unspecified address (::)
      } else if ip_cidr_contains(["::ffff:0:0:0/96"], .source.ip) ?? false {
          .source.ip_type = "ipv4_translated" # IPv4-translated IPv6
      } else if !is_null(.source.ip) {
          .source.ip_type = "public"
      } #else {
      #    .source.ip_type = "unknown"
      #}

      # destination
      .destination.ip = .panos.dst
      .destination.port = to_int( string(.panos.dport) ?? "nonum" ) ?? null
      .destination.mac = .panos.dst_mac
      .destination.nat.ip = .panos.natdst
      .destination.nat.port = to_int( string(.paos.natdport) ?? "nonum" ) ?? null
      .destination.user.name = .panos.dstuser
      .destination.bytes = to_int( string(.panos.bytes_received) ?? "nonum" ) ?? null
      .destination.packets = to_int( string(.panos.pkts_received) ?? "nonum" ) ?? null

      # Function to classify an IP address based on its type (IPv4 & IPv6)
      if ip_cidr_contains(["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"], .destination.ip) ?? false {
          .destination.ip_type = "private"
      } else if ip_cidr_contains(["127.0.0.0/8", "::1/128"], .destination.ip) ?? false {
          .destination.ip_type = "loopback"
      } else if ip_cidr_contains(["169.254.0.0/16", "fe80::/10"], .destination.ip) ?? false {
          .destination.ip_type = "link_local"
      } else if ip_cidr_contains(["224.0.0.0/4", "ff00::/8"], .destination.ip) ?? false {
          .destination.ip_type = "multicast"
      } else if ip_cidr_contains(["100.64.0.0/10"], .destination.ip) ?? false {
          .destination.ip_type = "carrier_nat"
      } else if ip_cidr_contains(["192.0.0.0/24", "192.0.2.0/24", "198.51.100.0/24", "203.0.113.0/24", "2001:db8::/32"], .destination.ip) ?? false {
          .destination.ip_type = "documentation"
      } else if ip_cidr_contains(["240.0.0.0/4", "2001::/23", "4000::/2"], .destination.ip) ?? false {
          .destination.ip_type = "reserved"
      } else if ip_cidr_contains(["100::/64"], .destination.ip) ?? false {
          .destination.ip_type = "discard" # IPv6 discard prefix (RFC 6666)
      } else if ip_cidr_contains(["2002::/16"], .destination.ip) ?? false {
          .destination.ip_type = "6to4_tunnel" # IPv6 6to4 tunneling
      } else if ip_cidr_contains(["::ffff:0:0/96"], .destination.ip) ?? false {
          .destination.ip_type = "ipv4_mapped" # IPv4-mapped IPv6
      } else if ip_cidr_contains(["::/128"], .destination.ip) ?? false {
          .destination.ip_type = "unspecified" # Unspecified address (::)
      } else if ip_cidr_contains(["::ffff:0:0:0/96"], .destination.ip) ?? false {
          .destination.ip_type = "ipv4_translated" # IPv4-translated IPv6
      } else if !is_null(.destination.ip) {
          .destination.ip_type = "public"
      } #else {
      #    .destination.ip_type = "unknown"
      #}

      # PanOS duration is on seconds, and ECS specifies it should be on nanoseconds
      .event.duration = to_int(string(.panos.elapsed)?? "nonum") * 1000000000  ?? null

      # observer
      .observer.egress.interface.name = .panos.outbound_if
      .observer.ingress.interface.name = .panos.inbound_if
      .observer.egress.zone.name = .panos.to
      .observer.ingress.zone.name = .panos.from

      # network
      .network.bytes = to_int( string(.panos.bytes) ?? "nonum" ) ?? null
      .network.packets = to_int( string(.panos.packets) ?? "nonum" ) ?? null
      .network.application = .panos.app
      .network.transport = to_string(.panos.proto) ?? null
      .network.transport_port = to_string(.network.transport)  + "/" + to_string(.destination.port)

      .panos.characteristic_of_app = split(.panos.characteristic_of_app, ",") ?? [null]

      iana = get_enrichment_table_record("iana_number", { "Keyword": (upcase(.network.transport) ?? null ) } ) ?? null 
      .network.iana_number = to_int(iana.Decimal) ?? null

      ## community_id
      .network.community_id = community_id(source_ip: .source.ip, destination_ip: .destination.ip, source_port: .source.port, destination_port: .destination.port, protocol: .network.iana_number) ??  null

      ## network.direction
      if ip_cidr_contains($INTERNAL_NETWORKS , .source.ip) ?? false {
          .source.isInternal = true
      } else if includes(["private", "loopback", "link_local", "multicast", "carrier_nat"], .source.ip_type) {
         .source.isInternal = true
      } else if !is_null(.source.ip) {
          .source.isInternal = false
      }

      if ip_cidr_contains($INTERNAL_NETWORKS , .destination.ip) ?? false {
          .destination.isInternal = true
      } else if includes(["private", "loopback", "link_local", "multicast", "carrier_nat"], .destination.ip_type) {
          .destination.isInternal = true
      } else if !is_null(.destination.ip) {
          .destination.isInternal = false
      }

      if !exists(.source.isInternal) || !exists(.destination.isInternal) {
        .network.direction = null
      } else if ((.source.isInternal) && (.destination.isInternal) ) ?? false {
        .network.direction = "internal"
      } else if ((.source.isInternal) && !to_bool(.destination.isInternal) ) ?? false {
        .network.direction = "outbound"
      } else if (!to_bool(.source.isInternal) && (.destination.isInternal) ) ?? false {
        .network.direction = "inbound"
      } else if (!to_bool(.source.isInternal) && !to_bool(.destination.isInternal) ) ?? false {
        .network.direction = "external"
      } else {
        .network.direction = "unknown"
      }



      # rule
      #.rule.id = .panos.policy_id
      .rule.name = .panos.rule
      .rule.uuid = .panos.rule_uuid

      # session
      .session.id = .panos.sessionid

      # http
      .http.response.mime_type = .panos.contenttype
      .http.request.referrer = .panos.referer
      .http.request.method = .panos.http_method

      # user_agent
      .user_agent = parse_user_agent(.panos.user_agent) ?? null

      # url
      #.url |= parse_url(.panos.misc) ?? {}
      # panos_values_array[3] is "subtype" in all PANOS logs
      if includes(["file", "virus", "wildfire-virus", "wildfire"], panos_values_array[3]) {
        .file.name = .panos.misc
      } else if panos_values_array[3] == "url" {
        .url.original = .panos.misc
      } 

      # file
      .file.type = .panos.filetype
      .file.hash.sha256 = .panos.filedigest

      # delete null fields
      . = compact(.)

# Print parsed logs to stdout
sinks:
  #  print:
  #   type: "console"
  #   inputs: ["remap_pan"]
  #   encoding:
  #        #      codec: "raw_message"
  #     codec: "json"
  #     json:
  #        pretty: true

  vlogs_panos:
    inputs:
      - remap_pan
    type: elasticsearch
    endpoints:
      #- http://${VICTORIA_LOGS_HOSTNAME:-localhost}:${VICTORIA_LOGS_PORT:-9428}/insert/elasticsearch/
      - ${VICTORIA_LOGS_ENDPOINT:-http://localhost:9428}/insert/elasticsearch/
    api_version: v8
    compression: gzip
    healthcheck:
      enabled: false
    query:
      _msg_field: message
      _time_field: timestamp
      _stream_fields: observer.product,observer.type,observer.vendor,observer.name,log.syslog.hostname,panos.device_name,panos.vsys,panos.type,panos.subtype,network.direction
    request:
      headers:
        AccountID: "0"
        ProjectID: "0"
    ### For performance optimization. Vector works really well with defaults. Don't use it unless you really need to fine-tune yor ingest.
    buffer:
      - type: memory
        max_events: 12800 # default 500 https://www.elastic.co/docs/reference/fleet/es-output-settings#es-output-settings-performance-tuning-settings
        #when_full: drop_newest #default block
    batch:
      #max_bytes:
      max_events: 1600 # default 1000
      timeout_secs: 5 # default 1

  elastic_panos:
    type: elasticsearch
    inputs:
      - remap_pan
    auth:
      strategy: "basic"
      user: "${ELASTICSEARCH_USER:-elastic}"
      password: "${ELASTICSEARCH_PASS:-myelasticsearchpassword}"
    endpoints:
      #- https://${ELASTICSEARCH_HOSTNAME:-localhost}:${ELASTICSEARCH_PORT:-9200}
      - ${ELASTICSEARCH_ENDPOINT:-https://localhost:9200}
    encoding:
      except_fields:
        - url.query
    mode: "data_stream"
    bulk:
      action: "create"
    data_stream:
      type: "logs"
      dataset: "panos.{{panos.type}}"
      namespace: "default"
    ### For performance optimization. Vector works really well with defaults. Don't use it unless you really need to fine-tune yor ingest.
    buffer:
      - type: memory
        max_events: 12800 # default 500 https://www.elastic.co/docs/reference/fleet/es-output-settings#es-output-settings-performance-tuning-settings
        #when_full: drop_newest #default block
    batch:
      #max_bytes:
      max_events: 1600 # default 1000
      timeout_secs: 5 # default 1

#  quickwit_panos:
#    type: "http"
#    method: "post"
#    inputs:
#      - remap_pan
#    encoding:
#      codec: "json"
#    framing:
#      method: "newline_delimited"
##    uri: "http://${QUICKWIT_HOSTNAME:-localhost}:${QUICKWIT_PORT:-7280}/api/v1/logs-panos.{{panos.type}}/ingest"
#    uri: "${QUICKWIT_ENDPOINT:-http://localhost:7280}/api/v1/logs-panos.{{panos.type}}/ingest"

#  loki_panos:
#    type: loki
#    inputs:
#      - remap_pan
#    endpoint: https://${LOKI_HOSTNAME:-localhost}:${LOKI_PORT:-3100}
#    endpoint: ${LOKI_endpoint:-https://localhost:3100}
#    auth:
#      strategy: "basic"
#      user: "${LOKI_USER:-loki_user}"
#      password: "${LOKI_PASS:-mylokipassword}"
#    encoding:
#      codec: "json"
#    compression: "snappy"
#    labels:
#      "syslog_appname": "{{.log.syslog.appname}}"
#      "syslog_hostname": "{{.log.syslog.hostname}}"
#      "panos_device_name": "{{.panos.device_name}}"
#      "panos_virtual_system": "{{.panos.virtual_system}}"
#      "panos_type": "{{.panos.type}}"
#      "panos_threat/content_type": "{{.panos.threat/content_type}}"
#      #"network_direction": "{{.network.direction}}"
#    #structured_metadata:
#     # "source_ip": "{{source.ip}}"
#     # "destination_ip": "{{destination.ip}}"
#     # "destination_port": "{{destination.port}}"
#     # "network_transport_port": "{{network.transport_port}}"
#    ### For performance optimization. Vector works really well with defaults. Don't use it unless you really need to fine-tune yor ingest.
#    buffer:
#    - type: memory
#      max_events: 12800 # default 500 https://www.elastic.co/docs/reference/fleet/es-output-settings#es-output-settings-performance-tuning-settings
#      #when_full: drop_newest #default block
#    batch:
#      #max_bytes:
#      max_events: 1600 # default 1000
#      timeout_secs: 5 # default 1
